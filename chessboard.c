#include <stdio.h>
int main()
{
    int i,j,judge;//a是棋盘
    long int a[6][6]={0};
    int rangwokankan(long int b[6][6]);
    a[0][0]=a[4][2]=a[4][5]=a[5][4]=1;
    a[0][1]=a[0][3]=a[1][3]=a[2][4]=a[2][5]=a[5][1]=0;//已知棋位置
    for (i=0; i<6; i++)
    {
        for (j=0; j<6; j++)
        {
            printf("%ld\t",a[i][j]);
        }
        printf("\n");
    }
    putchar('\n');//这里把原棋局情况进行一次还原，主要是为了后期观察，看这一步前面的操作有没有问题

    for(i=0;i<6;i++)//这里是启发于二进制加法的循环，加一后，第一位是0，那就变成一；如果第一位是1，那就第一位变成0，下一位变成1，如此如此...
    {
        for(j=0;j<6;j++)
        {
            if((i==0 && j==0)|| (i==4 && j==2)||(i==4 && j==5)||(i==5 && j==4)||(i==0 && j==1)||(i==0 && j==3)||(i==1 && j==3)||(i==2 && j==5)||(i==5 && j==1)||(i==2 && j==4))
            continue;//这是是碰到已知棋就跳过
            else//活棋的运算
            { 
                if (a[i][j]==0) //加一后，第一位是0，那就变成一
                {
                    a[i][j]=1;
                    judge = rangwokankan(a);//判断函数，观察现在的棋盘满不满足要求
                    if(judge == 1)  //满足要求
                    {
                        i=6;//跳出外循环的前提，好妙，多亏先锋学长
                        break;//跳出内循环
                    }
                    else            
                    {
                        i=-1;//从头循环的前提
                        break;//跳出内循环
                    }
                }
               else //如果第一位是1，那就第一位变成0
               {
                a[i][j]=0;
               }//循环特性会直接到下一个活棋
            }
        }
    }
   //最后结果展现
     for (i=0; i<6; i++)//二维棋局展现
    {       
        for (j=0; j<6; j++)
        {
            printf("%ld\t",a[i][j]);
        }
        putchar('\n');
    }
     for (i=0; i<6; i++)//一维棋局展现
    {       
        for (j=0; j<6; j++)
        {
            printf("%ld",a[i][j]);
        }
    }
    putchar('\n');
    return 0;
}

int rangwokankan(long int b[6][6])//判断函数
{
    int judge,i,j,m,k; 
    long int c[6]={};
    for (i=0; i<6; i++)//行
    {
        if ((b[i][0]+b[i][1]+b[i][2]+b[i][3]+b[i][4]+b[i][5])!=3) return (0);//三黑三白
        for (j=0; j<4; j++)
        {
            if ((b[i][j]+b[i][j+1]+b[i][j+2])==0 || (b[i][j]+b[i][j+1]+b[i][j+2])==3) return (0);//连着三黑连着三白
        }
    }

    for (j=0; j<6; j++)//列
    {
        if ((b[0][j]+b[1][j]+b[2][j]+b[3][j]+b[4][j]+b[5][j])!=3) return (0);//三黑三白
        for (i=0; i<4; i++)
        {
            if ((b[i][j]+b[i+1][j]+b[i+2][j])==0 || (b[i][j]+b[i+1][j]+b[i+2][j])==3) return (0);//连着三黑连着三白
        }
    }

    for (i=0; i<6; i++)//行列无相同
    {
        for (j=0; j<6; j++)
        {
            k=1;
            for (m=5-j;m>0;m--)//<stdio.h>不支持幂运算
            {
                k *= 10;
            }
            c[i] = c[i] + b[i][j]*k;//每行的组合比如 1，0，1，1，0，0，那c[i]=101100
        //or:  c[i] = c[i]*10 + b[i][j],更快，更简单，时间和空间复杂度都更低
        }
    }
    for (i=0; i<6; i++)//逐一比较
    {
        for (j=i+1; j<6; j++)
        {
            if(c[i] == c[j])  return (0);
        }
    }//由行列式，可知，行满秩，列满秩，所以没必要算列的
    return (1);
}
